IEnumerator backtrip(){
        bool [,] retEarn= new bool [ROW,ROW];
        for(int i=0;i<ROW;i++){
            for(int j=0;j<ROW;j++){
            retEarn[i,j]=false;
            }
        }
        for(int i=0;i<trips.Count;i++){
            retEarn[trips[i].Key,trips[i].Value]=true;
        }
            String str="";
        for(int i=0;i<ROW;i++){
            for(int j=0;j<ROW;j++){
                if(retEarn[i,j]==false){
                    str+="0";
                }else{
                    str+="1";
                }
            }
        }
            Debug.Log(str);
    Debug.Log("starting return journey \n");
        while(cur.Key!=4 || cur.Value!=0){

            for(int i=0;i<4;i++){
             Debug.Log(celler[cur.Key,cur.Value].wall[i]+" | ");     
            }

            Debug.Log(cur.Key);
            Debug.Log(cur.Value);
        if(celler[cur.Key,cur.Value].wall[0] && retEarn[cur.Key-1,cur.Value]){
            MoveTop();
            retEarn[cur.Key,cur.Value]=false;
            cur=new KeyValuePair<int, int>(cur.Key-1, cur.Value);
        }
        else if(celler[cur.Key,cur.Value].wall[1] && retEarn[cur.Key+1,cur.Value]){
            MoveDown();
            retEarn[cur.Key,cur.Value]=false;
            cur=new KeyValuePair<int, int>(cur.Key+1, cur.Value);
        }
        else if(celler[cur.Key,cur.Value].wall[2] && retEarn[cur.Key,cur.Value+1]){
            MoveRight();
            retEarn[cur.Key,cur.Value]=false;
            cur=new KeyValuePair<int, int>(cur.Key, cur.Value+1);
        }
        else if(celler[cur.Key,cur.Value].wall[3] && retEarn[cur.Key,cur.Value-1]){
            MoveLeft();
            retEarn[cur.Key,cur.Value]=false;
            cur=new KeyValuePair<int, int>(cur.Key, cur.Value-1);
        }
        yield return new WaitForSeconds(0.03f);
        }
    }
